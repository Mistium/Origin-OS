import "rotur/v1" from "packages" as "rotur"
import as "glass" from "packages"

file "use_type" "txt"

save "Studio" "set_directory"

permission "request" "file admin"
permission "request" "notifications"

array pickers = []

state = {
  folder: null,
  folder_open: true,
  folder_sidebar: false,
  folder_sidebar_width: 300,
  open_folders: [],
  folder_list_len: 0,
  linked_windows_view: false,
  linked_windows_scroll: [0,0],
  linked_windows_height: 0,
  linked_windows: [],

  // adds to 1, uses percentages for each split
  split_sizes: [1],

  // resize state
  split_resizing: 0,
  split_resize_start_x: 0,
  split_resize_start_left: 0,
  split_resize_start_right: 0,

  folder_resizing: false,
  folder_resize_start_x: 0,
  folder_resize_start_w: 300
}

number right = 0
number right_smooth = 0

number bottom = 0
number bottom_smooth = 0

boolean uses_mouse = ["Windows", "Linux"].contains(system_os)

inputs.linked_windows = []

class pages (
  def home() (
    goto 0 0
    square frame.width - 10 frame.height - 10 10 : c#window_colour
    w = frame.width / 2 - 20
    w2 = w - 5
    loc 2 2 20 -25
    text "New File" 8 : c#c_text

    loc 999 2 20 -25
    text "Recent Files" 8
    
    loc 2 2 w / 2 + 20 -200
    square w2 30 10 : c#c_seco
    if onclick (
      file "pick"
      void pickers.append(data)
      // list of windows that can send us transmits
    )
    change_x w2 / -2 + 10
    text "Open File" 9 : c#c_text

    // loc 2 2 w / 2 + 20 -250
    // square w2 30 10 : c#c_seco
    // if onclick (
    //   add_tab tab_types.invite
    // )
    // change_x w2 / -2 + 10
    // text "Live Share" 9 : c#c_text

    loc 2 2 w / 2 + 20 -65
    square w2 30 10 : c#c_prim
    input w2 - 10 25 "name" "hello world.txt" 10 c_text
    change_y -55
    local idx = inputs.name.index(".")
    if idx > 1 and idx < inputs.name.len (
      square w2 30 10 : c#c_seco cursor#pointer
      if mouse_touching (
        square w2 30 15 : c#global_accent
        square w2 30 10 : c#c_seco
      )
      if onclick or "enter".onKeyDown() (
        file "download" input_name
        add_tab {
          type: "file",
          name: input_name,
          id: ouidNew(),
          data: [],
          uuid: data,
          ohf: compileOHF(getOHF(input_name.split(".").last())),
          func: editor.renderNorm
        }
      )
      change_x w2 / -2 + 15
    ) else (
      square w2 30 10 : c#c_prim
      change_x w2 / -2 + 15
    )
    c c_text
    icon "Add" 0.5
    text "Create New File" 8 : chx#20

    c c_prim
    frame 10 frame.top - 40 frame.right - 10 frame.bottom recent_2.len * 55 "cache@" (
      w = frame_width - 20
      for count recent_2.len (
        y = count * -55 + 30 + scroll_y
        loc 999 2 0 y
        square w 30 10 : c#c_prim cursor#pointer
        cur = recent_2[count].toStr()
        name @= open(cur, [2, 1])
        if mouse_touching (
          if onclick (
            add_tab {
              type: "file",
              data: open(cur).split("\n"),
              name: name.join(""),
              id: ouidNew(),
              uuid: cur,
              ohf: compileOHF(getOHF(name[2])),
              func: editor.renderNorm
            }
          )
          square w 30 15 : c#c_seco
          square w 30 10 : c#c_prim
        )
        change w / -2 + 12
        if loaded_file !== 0 (
          file "render" 1
          loc 2 2 40 y
          text name.join("") 9 : c#c_text
        ) else (
          recent.delete(count)
          save "recent_files.json" "set" recent
          count --
          recent2 = recent.trim(1,10)
        )
      )
    )
  )

  def invite() (
    goto 0 0
    square frame.width - 10 frame.height - 10 10 : c#window_colour
    window "responsive" true
    frame window.left + 300 window.top - 40 window.right window.bottom (
      goto 0 40
      centext "Type a user's connection id to invite" 10 : c#c_text
      goto 0 20
      centext "Your id is: " ++ connection.username 9
      goto 0 -20
      square 300 25 10 : c#c_prim
      input 260 25 "Invite" "Should look like: '06ec19ff33'" : chx#-20
      c sharing_tab == null ? c_seco c_text
      icon "send" 0.8 : chx#150 tooltip#"Send Invite to Edit"
      if onclick and sharing_tab != null (
        edit_session = ouidNew()
        host = true
        rotur.pMessage(connection.room, "ori-" ++ inputs.Invite, {
          cmd: "join",
          ohf: getOHF(open(sharing_tab, ["type"])[1]),
          room: edit_session,
          file_data: open(sharing_tab, "all")
        })
        joinEditSession(edit_session)
      )
      c c_text
      goto 0 -55
      centext "Recieved:" 9
      each invite invites.getKeys() (
        change_y -45
        square frame.width - 30 30 10 : c#c_prim
        if onclick (
          sharing_tab = ""
          tabs = tabs.filter(v -> !v.startsWith("^ "))
          joinEditSession(invites[invite].val.room)
          local file_data = invites[invite].val.file_data
          save_name = "temp_" ++ file_data[14] ++ ".lvsh"
          save save_name "set" file_data[4]
          sharing_tab = save_name.saveGet(14)
          inputs.share = file_data[4].split("\n")
          last_inputs_share = inputs.share
          share_name = file_data[2] ++ file_data[1]
          share_type = file_data[1]
          current_ohf = invites[invite].val.ohf
          if typeof(current_ohf) == "object" (
            current_ohf = compileOHF(current_ohf)
          ) else (
            current_ohf = null
          )
          add_tab "^ " ++ file_data[14]
          invites = {}
        )
        centext "From " ++ invites[invite].origin.username 10 : c#c_text
      )
    )
    frame window.left + 45 window.top - 35 window.left + 300 window.bottom (
      square frame.width - 25 frame.height - 25 15 : c#c_prim
      square frame.width - 25 frame.height - 25 10 : c#window_colour
      goto 0 frame.top + 15
      each tab tabs (
        if tab.len == 32 (
          change_y -45
          if sharing_tab == tab (
            square frame.width - 30 30 15 : c#global_accent
          )
          square frame.width - 30 30 10 : c#c_prim
          if clicked (
            sharing_tab = tab
          )
          centext open(tab, ["name", "type"]).join("") 10 : c#c_text
        )
      )
    )
  )
)

tab_types = {
  welcome: {name: "Welcome", func: pages.home},
  invite: {name: "Invite", func: pages.invite},
  editor: {name: "Editor", func: editor.renderNorm}
}

class sidebar (
  mode = "none"
  fn = () -> ()
  resize = 0.5

  _resizing = false
  resize_start_x = 0
  resize_start_value = 0
  
  def frameInnerRender(callback) (
    if self.resizing and !mouse_down (
      self.resizing = false
    )
    if self.mode == "none" (
      callback()
      return
    )
    local w = self.resize * frame.width
    
    local join_x = frame.right - w
    
    frame join_x frame.top frame.right frame.bottom (
      goto 0 0
      square frame.width frame.height 10 : c#c_prim
      self.fn()
    )
    if abs(mouse_x - join_x) < 20 (
      cursor "ew-resize"
      if mouse_ondown (
        self.resizing = true
        self.resize_start_x = mouse_x
        self.resize_start_value = self.resize
      )
    )
    frame frame.left frame.top join_x frame.bottom (
      callback()
    )
    if self.resizing (
      self.resize = (self.resize_start_value + (self.resize_start_x - mouse_x) / frame.width).clamp(0.2,0.8)
    )
  )
)

def ensureSplitSizes() (
  local n = split_tabs.len
  if n <= 0 (
    state.split_sizes = [1]
    return
  )
  if typeof(state.split_sizes) != "array" or state.split_sizes.len != n (
    state.split_sizes = []
    local each = 1 / n
    for i n (
      void state.split_sizes.append(each)
    )
  )
  local sum = 0
  for i n (
    state.split_sizes[i] = (state.split_sizes[i] ?? (1 / n)).toNum()
    state.split_sizes[i] = state.split_sizes[i].clamp(0.08, 0.92)
    sum += state.split_sizes[i]
  )
  if sum != 0 (
    for i n (
      state.split_sizes[i] /= sum
    )
  )
)

class editor (
  def renderNorm() (
    local tab @= tabs[current_tab]
    goto 0 -18
    square frame.width - 12 frame.height - 49 10 : c#window_colour
    c c_prim
    inputs[tab.id] @= tab.data
    textbox frame.width - 4 frame.height - 39 tab.id 0 {
      line_numbers: {
        bg_colour: c_prim
      },
      sel_colour: c_seco,
      text_colour: c_text,
      ohf: tab.ohf
    }
    local sel @= inputs.selected
    local err @= tab.errors.sortBy("line")
    local data @= inputs[tab.id]
    local offset @= data.len.len * 8 + 30
    for i err.len (
      local cur @= err[i]
      if err[i - 1].line == cur.line (
        continue
      )
      goto frame.left + (data[cur.line].len * 10 + offset) frame.top - 50 - (cur.line - 1 * 23) + tab.scroll.y
      text cur.message 10 : c#f66
    )
    if sel.id == tab.id (
      tab.scroll @= sel.scroll
      if sel.changed (
        tab.unsaved = true
        tabs[current_tab].data @= inputs[tab.id]
        if tab["type"] == "file" and tab.name.endsWith(".osl") and false (
          resp @= promise.new(def() -> (
            local ast = osl.generateAST(tab.data.join("\n"))
            self.tab.errors @= osl.getErrorsFromAST(ast)
          ))
          resp.worker.tab @= tab
        )
      )
    )
    
    goto 0 frame.top - 16.5
    square frame.width - 12 20 10 : c#window_colour
    loc 2 2 15 -16.5
    sidebarbuttons(tab.uuid, tab.id)
  )
  
  def renderShare() (
    local tab @= tabs[current_tab]
    window "responsive" true
    current_studio_page = "Sync"
    goto 0 0
    c c_prim
    textbox frame.width window.height - 45 "share" 0 {
      line_numbers: {
        bg_colour: c_prim
      },
      sel_colour: c_seco,
      text_colour: c_text,
      ohf: tab.ohf
    }

    if inputs.selected.id == "share" (
      if inputs.selected.cursor != last_cursor (
        last_cursor = inputs.selected.cursor
        rotur.gMessage(edit_connection.room, {
          cmd: "cursor",
          data: last_cursor
        })
      )
      if inputs.share.len != last_input_share.len (
        rotur.gMessage(edit_connection.room, {
          cmd: "full",
          data: inputs.share.join("\n")
        })
        last_input_share = inputs.share
      ) else if inputs.share.join("\n") != last_input_share.join("\n") (
        for i inputs.share.len (
          if inputs.share[i] != last_input_share[i] (
            rotur.gMessage(edit_connection.room, {
              cmd: "line",
              line: i,
              data: inputs.share[i].toStr()
            })
          )
        )
        last_input_share = inputs.share
      )
    )
  )
)

class icnPreview (
  def render() (
    local tab @= tabs[current_tab]
    frame frame.left frame.top - 39 frame.right frame.bottom (
      goto 0 0
      square frame.width - 12 frame.height - 12 10 : c#window_colour

      tab.icn_state ??= {
        display: [0,0],
        last_display: [0,0],
        mouse: [0,0],
        zoom: 1
      }

      local icn @= tab.icn_state
      local lines = []
      if tab.source_input != null and inputs[tab.source_input] != null (
        lines @= inputs[tab.source_input]
      ) else if tab.source_uuid != null (
        lines = open(tab.source_uuid).split("\n")
      )

      if mouse_touching (
        if mouse_down (
          icn.display = icn.last_display - (icn.mouse - [mouse_x, mouse_y])
        ) else (
          icn.last_display = icn.display
          icn.mouse @= [mouse_x, mouse_y]
        )
        icn.zoom += uses_mouse ? scroll_velocity / -100 scroll_velocity / 10
        icn.zoom = icn.zoom.clamp(0.1, 20)
      ) else if !mouse_down (
        icn.last_display = icn.display
        icn.mouse @= [mouse_x, mouse_y]
      )

      goto icn.display
      c c_seco
      icon "w 0 square 0 0 10 9999 square 0 0 9999 10 w 5 c" + c_text + lines.join(" ") icn.zoom
    )

    goto 0 frame.top - 16.5
    square frame.width - 12 20 10 : c#window_colour
    loc 2 2 15 -16.5

    local h = 30
    local s = 0.65

    c c_text
    icon "minus" s : tooltip#"Zoom Out"
    square 30 30 12 1 1
    if onclick (
      icn.zoom = (icn.zoom / 1.25).clamp(0.1, 20)
    )

    change_x h
    icon "add" s : tooltip#"Zoom In"
    square 30 30 12 1 1
    if onclick (
      icn.zoom = (icn.zoom * 1.25).clamp(0.1, 20)
    )
  )
)

def updateLinkedWindowLogs() (
  for i state.linked_windows.len (
    local cur @= state.linked_windows[i]
    local win @= cur.context.window
    local logs @= win.logs
    if cur.total_logs < logs.len (
      for j logs.len - cur.total_logs (
        local log @= logs[cur.total_logs + j]
        local idx @= log.index(": ")
        if idx != -1 (
          log @= log.trim(idx + 2, -1)
        )
        void inputs.linked_windows.append(log)
      )
      cur.total_logs = logs.len
    )
    if win.dead (
      void state.linked_windows.delete(i)
      i --
    )
  )
)

class logsTab (
  def render() (
    goto 0 -18
    square frame.width - 12 frame.height - 49 10 : c#window_colour

    updateLinkedWindowLogs()

    goto 0 frame.top - 16.5
    square frame.width - 12 20 10 : c#window_colour
    loc 2 2 15 -16.5
    local h = 30
    local s = 0.65

    c c_text
    icon "close" 0.6 : tooltip#"Clear logs"
    square 30 30 12 1 1
    if onclick (
      inputs.linked_windows = []
      state.linked_windows_scroll = [0,0]
      for i state.linked_windows.len (
        state.linked_windows[i].total_logs = 0
      )
    )

    if state.linked_windows.len == 0 and inputs.linked_windows.len == 0 (
      goto 0 0
      centext "No linked windows, run an osl app to see logs here" 9 : c#c_text
      return
    )

    local lscroll @= state.linked_windows_scroll
    frame frame.left + 5 frame.top - 45 frame.right - 5 frame.bottom + 5 state.linked_windows_height "cache@logs_tab" (
      goto 0 0
      square frame.width - 10 frame.height - 10 10 : c#window_colour
      if mouse_touching (
        lscroll[2] -= scroll.y.velocity
        lscroll[2] = lscroll[2].clamp(0, state.linked_windows_height)
      )
      loc 2 -2 10 20 - lscroll[2]
      local x = x_position
      local i = inputs.linked_windows.len
      local w = frame.width / 10 - 5
      local hgt = 0
      loop i (
        local cur @= inputs.linked_windows[i]
        local parts = cur.wrapText(w).split("\n")
        local j = parts.len
        loop j (
          set_x x
          text parts[j] 10 : c#c_text
          change_y 23
          hgt += 23
          if y_position > frame.top + 20 (
            break
          )
          j --
        )
        change_y 10
        hgt += 10
        i --
      )
      state.linked_windows_height = hgt
    )
  )
)

class searchTab (
  def render() (
    local tab @= tabs[current_tab]
    goto 0 -18
    square frame.width - 12 frame.height - 49 10 : c#window_colour

    goto 0 frame.top - 16.5
    square frame.width - 12 20 10 : c#window_colour
    loc 999 2 0 -16.5
    local s = 0.65

    local input_id = "search_" ++ tab.id
    square frame.width - 90 20 8 : c#c_prim
    input frame.width - 90 25 input_id "Search" 5 c_text
    local q = inputs[input_id] ?? ""

    local lines = []
    if tab.source_uuid != null (
      lines @= open(tab.source_uuid).split("\n")
    )

    tab._last_q ??= ""
    tab.results ??= []
    if q != tab.last_q (
      tab.last_q = q
      tab.results = []
      local q2 = q.toUpper()
      if q2.len > 0 (
        for i lines.len (
          local line = lines[i].toStr()
          if line.toUpper().contains(q2) (
            void tab.results.append({
              line: i,
              text: line.strip()
            })
          )
          if tab.results.len > 100 (
            break
          )
        )
      )
    )

    local results @= tab.results
    if q.len == 0 (
      goto 0 0
      centext "Type to search this file" 9 : c#c_text
      return
    )

    if results.len == 0 (
      goto 0 0
      centext "No results" 9 : c#c_text
      return
    )

    local content_h = results.len * 25
    c c_prim
    frame frame.left + 5 frame.top - 45 frame.right - 5 frame.bottom + 5 content_h "cache@search_tab" (
      goto 0 frame.top + frame.scroll - 12
      local w = frame.width - 10
      for i results.len (
        local r @= results[i]
        set_x 0
        square w 20 8 0 1 : cursor#pointer
        if mouse_touching (
          square w 20 8 : c#c_seco
          if onclick (
            if tab.source_tab_id != null (
              local idx = 0
              for t tabs.len (
                if tabs[t].id == tab.source_tab_id (
                  idx = t
                  break
                )
              )
              if idx != 0 (
                current_tab = idx
              )
            )
          )
        )
        set_x frame.left + 10
        text r.line.toStr() ++ ": " 9 : c#c_seco
        text r.text 9 : chx#10 c#c_text
        change_y -25
        if y_position < frame.bottom - 25 (
          break
        )
      )
    )
  )
)

window.show()

def joinEditSession(id) (
  if edit_connection != null (
    rotur.unSubscribe(edit_connection.room)
  )
  edit_connection @= rotur.subscribe(id, my_id)
  edit_connection.onmessage = def(packet) -> (
    switch packet.val.cmd (
      case "full"
        inputs.share = packet.val.data.split("\n")
        last_input_share = inputs.share
        break
      case "reqfull"
        rotur.gMessage(edit_connection.room, {cmd:"full", data: inputs.share.join("\n")})
        break
      case "rename"
        share_name = packet.val.name
        break
      case "line"
        inputs.share[packet.val.line] = packet.val.data
        last_input_share[packet.val.line] = packet.val.data
        break
      case "cursor"
        cursors[packet.origin] = packet.val
        break
    )
  )
  edit_connection.onclose = def() -> (
    joinEditSession(edit_connection.room) 
  )
  edit_connection.onjoin = def() -> (
    inputs.share = open(sharing_tab).split("\n")
    share_name = open(sharing_tab, ["name", "type"])
    share_type = share_name[2]
    current_ohf = compileOHF(getOHF(share_type))
    share_name = share_name.join("")
    add_tab "^ Live Share"
  )
)

def getOHF(string type) (
  type = type.toUpper()
  if type.startsWith(".") (
    type.trim(2,-1)
  )
  local load_save = false
  if (type ++ ".ohf").saveExists() (
    load_save = timestamp - (type ++ ".ohf").saveGet(10) < 86400000
  )
  if load_save (
    return (type ++ ".ohf").saveGet()
  ) else (
    local OHF = requests.get("https://origin.mistium.com/Other/OHF/" ++ type.toUpper() ++ ".ohf")
    if OHF.status != 200 (
      return null
    )
    string name = type ++ ".ohf"
    if name.saveExists() (
      return name.saveGet()
    ) else (
      local parsed = OHF.body.JsonParse()
      save name "set" parsed
      return parsed
    )
  )
)

def compileOHF(ohf) (
  if typeof(ohf) != "object" (
    return ""
  )
  
  local output = {
    tokens: {},
    overrides: {},
    parser: {}
  }

  try (
    if ohf.categories != null (
      each o ohf.categories.getValues() (
        each r o.tokens (
          output.tokens["tkn:" ++ r] = o.color
        )
      )
    )
  
    if ohf.overrides != null (
      each o ohf.overrides.getKeys() (
        output.overrides[o] = ohf.overrides[o]
      )
    )
  
    output.parser = ohf.parser ?? {}
    output.highlighter = ohf.highlighter ?? {}
  ) catch o (
    error o
    return ""
  )

  return output
)

host = false
my_id = ouidNew().trim(1,3)

edit_session = null
edit_connection = null
sharing_tab = null
share_name = null

last_cursor = ""
last_share_input = ""

invites = {}
connection = {}
def setupRotur() (
  connection @= rotur.subscribe("Studio", my_id)
  connection.onmessage = def(packet) -> (
    if packet.val.cmd == "join" (
      invites[packet.origin.username] = packet
    )
  )
  connection.onclose = def() -> (
    setupRotur()
  )
)

// setupRotur()

change_focus = true
current_tab_target = 0
removed = false

tab_dragging = false
tab_drag_candidate = null
tab_drag_tab = null
tab_drag_from_split = 0
tab_drag_from_index = 0

tab_close_lock = false

if "recent_files.json".saveExists() (
  recent = "recent_files.json".saveGet()
) else (
  save "recent_files.json" "set" []
  recent = []
)
recent_2 = recent.trim(1,10)
save "recent_files.json" "set" recent_2

if "recent_folders.json".saveExists() (
  recent_folders = "recent_folders.json".saveGet()
) else (
  save "recent_folders.json" "set" []
  recent_folders = []
)
recent_folders_2 = recent_folders.trim(1,10)
save "recent_folders.json" "set" recent_folders_2

def loadFileUUID(uuid) (
  file = open(uuid, ["name", "type", "data"])
  inputs[uuid] = file[3].split("\n")
  file.pop()
)

tabs = []
current_tab = 1
if passed_data == "" (
  tabs.append(tab_types.welcome)
) else (
  change_focus = true
  local name = open(passed_data, ["name", "type"])
  tabs.append({
    type: "file",
    name: name.join(""),
    id: ouidNew(),
    data: open(passed_data).split("\n"),
    uuid: passed_data,
    ohf: compileOHF(getOHF(name[2])),
    func: editor.renderNorm
  })
  loadFileUUID(passed_data)
)
tabs_out = tabs
sidebar_items = 0

def "draw_buttons" (
  loc -2 2 -50 -20
  square 80 20 10 : c#window_colour
  loc -2 2 -20 -20
  
  icon "close" 0.6 : c#c_text
  if onclick (
    window "stop"
  )
  
  change_x -30
  icon "down" 0.6 : c#c_text
  if onclick (
    window "minimise"
  )

  change_x -30
  icon "maximise" 0.6 : c#c_text
  if onclick (
    window "maximise"
  )
  
  change_x -35
  square 20 20 10 : c#window_colour
  change_x 0
  icon "w 4 square 0 0 10 10 w 10 line 5 7 5 -7" 0.6 : c#c_text
  if onclick (
    state.folder_sidebar = !state.folder_sidebar
  )
)

def "add_tab" "data" (
  if data.id == null (
    data.id = ouidNew()
  )
  void tabs.append(data)
  change_focus = true
  current_tab = tabs.len
)

def "insert_tab" "index, data" (
  if data.id == null (
    data.id = ouidNew()
  )
  tabs.insert(index, data)
  change_focus = true
  current_tab = index
)

def "draw_tabs" (
  loc 2 2 9 -21
  local removed = false
  
  c c_text
  x = frame.left - 2.5 - frame.scroll_h
  start = x
  remove_tabs = []
  
  for i tabs.len (
    local tab @= tabs[i]
    local remove_immediately = false
    tw = 0
    tab_name = tab.name
    file = tab["type"] == "file"

    local can_drag_tab = split_tabs.len > 1 or tabs.len > 1
    if file (
      file "open" tab.uuid "onlyaccess"
    )
    
    local l = tab_name.len * 9 + 25
    if file (
      l += 20
    )
    tw += l + 25
    set_x x
    if file_dragging or tab_dragging (
      local offset = i == 1 ? 5 0
      change_x offset
      if dist(x_position,y_position,mouse_x,mouse_y) < 40 (
        square 0 20 2 : c#c_text
        current_tab_target = current_tab_split ++ "," ++ i
        change_x offset
        x += offset * 2
      ) else (
        change_x -offset
      )
    )
    change_x tw / 2

    square l + 10 20 10 : c#window_colour
    if file (
      change_x -10
      square l - 10 20 10 0 1
      change_x 10
    )

    if file (
      change_x -10
      if mouse_touching (
        rightclick "file" tab.uuid
      )
      if (mouse_down or mouse_touching) and !tab_dragging and tab_drag_candidate == null (
        file "interact"
        if data == "open" (
          current_tab = i
        )
        if data == "dragging" (
          if can_drag_tab (
            remove_immediately = true
          ) else if (
            data = ""
            file_dragging = false
          )
        )
      )
      change_x 10
    ) else (
      if mouse_touching (
        if !tab_dragging and tab_drag_candidate == null and mouse_down and !file_dragging and can_drag_tab (
          tab_drag_candidate = {
            split: current_tab_split,
            index: i,
            start: [mouse_x, mouse_y]
          }
        )
      )

      if tab_drag_candidate != null and tab_drag_candidate.split == current_tab_split and tab_drag_candidate.index == i and mouse_down and !file_dragging and can_drag_tab (
        if dist(tab_drag_candidate.start[1], tab_drag_candidate.start[2], mouse_x, mouse_y) > 10 (
          tab_dragging = true
          tab_drag_tab @= tab
          tab_drag_from_split = current_tab_split
          tab_drag_from_index = i
          tab_drag_candidate = null
          void tabs.delete(i)
          if current_tab > i (
            current_tab -= 1
          )
          if tabs.len == 0 (
            current_tab = 1
          ) else (
            current_tab.clamp(1, tabs.len)
          )
          i --
          continue
        )
      )

      if onclick (
        current_tab = i
      )
    )

    if remove_immediately (
      if edit_connection != null (
        rotur.unSubscribe(edit_connection.room)
      )
      tabs @= tabs.delete(i)
      i --
      removed = false
      remove_immediately = false
      continue
    )

    square l + 10 20 10 : c#window_colour
    if file (
      change_x -10
      square l - 10 20 10 0 1
      change_x 10
    )
    change_x l / -2
    if file (
      change_x 5
      file "render" 0.7
      change_x 15
    )
    c i == current_tab ? c_text c_seco
    text tab_name 9
    change_x 20
    if tab.unsaved (
      icon "w 20 dot 0 0" 0.5 : cursor#pointer
    ) else (
      icon "close" 0.5 : cursor#pointer
      if onclick (
        if !tab_close_lock (
          tab_close_lock = true
          removed = true
        )
      )
    )
    if removed (
      if edit_connection != null (
        rotur.unSubscribe(edit_connection.room)
      )
      tabs @= tabs.delete(i)
      i --
      removed = false
    )
    x += tw
  )
  if file_dragging or tab_dragging (
    change_x 17
    if dist(x_position,y_position,mouse_x,mouse_y) < 40 (
      square 0 20 2 : c#c_text
      current_tab_target = current_tab_split ++ "," ++ (i + 1)
    )
    change_x -17
  )
  if edit_connection == null (
    icon "add" 0.6 : chx#30 c#c_text
    if onclick (
      add_tab tab_types.welcome
    )
  )
  tab_width = x_position - start
)

def sidebarButtons(file_uuid, input_name) (
  c c_text
  local h = 30
  local s = 0.65
  icon "save" s : tooltip#"Save"
  square 30 30 12 1 1
  local path = open(file_uuid, ["location", "name", "type"])
  local file_type = path[3]
  if onclick or ("control".isKeyDown() and "s".onKeyDown()) (
    for i split_tabs.len (
      local cur @= split_tabs[i].tabs
      for j cur.len (
        local cur2 @= cur[j]
        if cur2["type"] == "file" and cur2.uuid == file_uuid (
          cur2.unsaved = false
        )
      )
    )
    path = path[1] ++ "/" ++ path[2] ++ path[3]
    file "set" 4 inputs[input_name].join("\n")
    recents = "recent_files.json".saveGet()
    save "recent_files.json" "set" recents.delete(file_uuid).prepend(file_uuid).trim(1,8)
  )
  
  change_x h
  if [".osl",".js",".bf",".owf"].contains(file_type) (
    icon "play" s : tooltip#"Run"
    square 30 30 12 1 1
    if onclick (
      local code = inputs[input_name].join("\n")
      switch file_type (
        case ".js"
          local parts = code.eval().split("\n")
          for i parts.len (
            void inputs.linked_windows.append(parts[i])
          )
          break
        case ".osl"
          window.create(file_uuid, {
            get_obj: true
          })
          // track the window and the total number of logs
          void state.linked_windows.append({ total_logs: 0, context: data })
          break
        default
          file "open" file_uuid "onlyaccess"
          file "start"
          file "close"
      )
    )
    change_x h
  )

  icon "move -2 2 scale 0.9 w 3 cutcircle -2 2 8 0 180 w 3.5 line 4 -4 12 -12" s : tooltip#"Search"
  square 30 30 12 1 1
  if onclick (
    local existing = 0
    for i tabs.len (
      if tabs[i].type == "search" and tabs[i].source_tab_id == input_name (
        existing = i
        break
      )
    )
    if existing != 0 (
      current_tab = existing
    ) else (
      add_tab {
        type: "search",
        name: "Search",
        id: ouidNew(),
        source_uuid: file_uuid,
        source_input: input_name,
        source_tab_id: input_name,
        func: searchTab.render
      }
    )
  )
  change_x h

  if file_type == ".osl" (
    icon "scale 2.2 w 1.5 line 0 -4 5 -4 line -2 0 -6 4 line -2 0 -6 -4" s : tooltip#"Logs"
    square 30 30 12 1 1
    if onclick (
      local existing = 0
      for i tabs.len (
        if tabs[i].type == "logs" (
          existing = i
          break
        )
      )
      if existing != 0 (
        current_tab = existing
      ) else (
        add_tab {
          type: "logs",
          name: "Logs",
          id: ouidNew(),
          func: logsTab.render
        }
      )
    )
    change_x h
  )
  if [".json", ".ohf", ".ojff"].contains(file_type) (
    if inputs[input_name].len == 1 (
      icon "line -10 10 5 10 line 0 2.5 10 2.5 line 0 -5 10 -5" 0.6
      if onclick (
        inputs[input_name] = inputs[input_name][1]
          .JsonParse()
          .JsonFormat()
          .split("\n")
      )
    ) else (
      icon "line -10 10 10 10 line -10 2.5 10 2.5 line -10 -5 5 -5" 0.6
      if onclick (
        inputs[input_name] = inputs[input_name]
          .join("\n")
          .JsonParse()
          .toStr()
          .split("\n")
      )
    )
    change_x h
  )

  if file_type == ".icn" (
    icon "eye" s
    square 30 30 12 1 1
    if onclick (
      add_tab {
        type: "icn_preview",
        name: "Preview: " ++ path[2] ++ file_type,
        id: ouidNew(),
        source_uuid: file_uuid,
        source_input: input_name,
        func: icnPreview.render
      }
    )
    change_x h
  )
  
  sidebar.mode = "none"
  
  // change_x h
  // icon "network" s
  // if onclick (
  //   add_tab tab_types.invite
  //   start = true
  // )
)

sharing_with = null

start = true

split_tabs = [{tabs, cur: 1}]

def drawFilesList(uuids) (
  local x = x_position
  for i uuids.len (
    file "open" uuids[i] "onlyaccess"
    local type = fileGet(1)
    set_x 0
    square frame.width - 20 20 5 0 1
    rightclick "file" uuids[i]
    set_x x
    if type != ".folder" (
      data = ""
      if mouse_touching and !tab_dragging and tab_drag_candidate == null (
        file "interact"
      )
      if data == "open" (
        local name = open(uuids[i], ["name", "type"])
        add_tab {
          type: "file",
          data: open(uuids[i]).split("\n"),
          name: name.join(""),
          id: ouidNew(),
          uuid: uuids[i],
          ohf: compileOHF(getOHF(name[2])),
          func: editor.renderNorm
        }
      )
    ) else (
      boolean folder_open = state.open_folders.contains(uuids[i])
      if onclick (
        if folder_open (
          void state.open_folders.delete(uuids[i])
        ) else (
          void state.open_folders.append(uuids[i])
        )
      )
      icon folder_open ? "down" "right" 0.5 : c#c_text
      change_x 25
    )
    file "render" 0.8
    text fileGet(2) 9 : c#c_text chx#18
    if type != ".folder" (
      text type 9 : c#c_seco
    )
    change_y -30
    if y_position < frame.bottom - 30 (
      break
    )
    if type == ".folder" (
      set_x x + 30
      if folder_open (
        local files @= fileGet(4)
        state.folder_list_len += files.len * 30
        drawFilesList(files)
      )
      set_x x
    )
  )
)

mainloop:

window "responsive" false
local theme = user.theme
c_prim = theme.primary
c_seco = theme.secondary
c_tert = theme.tertiary
c_text = theme.text
window_colour = theme.background

tab_close_lock = false

if change_focus and !start (
  change_focus = false
)
start = false

if !mouse_down (
  can = true
  if !tab_dragging (
    tab_drag_candidate = null
  )
)

w @= window

goto 0 window.top - 20
glass:frame w.left w.top w.right w.bottom
frame "clear"

updateLinkedWindowLogs()

if new_transmit (
  if pickers.contains(transmit_source) (
    local name = open(transmit_data, ["name", "type"])
    add_tab {
      type: "file",
      name: name.join(""),
      id: ouidNew(),
      data: open(transmit_data).split("\n"),
      uuid: transmit_data,
      ohf: compileOHF(getOHF(name[2])),
      func: editor.renderNorm
    }

    loadFileUUID(transmit_data)
  )
  new_transmit = false
)

if file_dropped != 0 (
  local name @= open(file_dropped, ["name", "type", "data"])
  if name[2] == ".shortcut" (
    local name @= open(name[3], ["name", "type", "uuid"])
    file_dropped = name[3]
  )
  if name[2] == ".folder" and current_tab_target == "folder_sidebar" (
    state.folder = file_dropped
    state.folder_open = true
    state.open_folders = []

    // Save recent folders
    local rf = "recent_folders.json".saveGet() ?? []
    save "recent_folders.json" "set" rf
      .delete(file_dropped)
      .prepend(file_dropped)
      .trim(1,8)
  ) else (
    local spl = current_tab_target.toStr().split(",")
    local cur @= split_tabs[spl[1]]
    if current_split_target != 0 (
      split_tabs.insert(current_split_target, {tabs:[], cur: 1})
      cur @= split_tabs[current_split_target]
    )
    current_tab_target = spl[2]
    if current_tab_target == 0 (
      current_tab_target = tabs.len + 1
    )
    tabs @= cur.tabs
    insert_tab current_tab_target {
      type: "file",
      name: name.trim(1,-2).join(""),
      id: ouidNew(),
      data: open(file_dropped).toStr().split("\n"),
      uuid: file_dropped,
      ohf: compileOHF(getOHF(name[2])),
      func: editor.renderNorm
    }
    cur.cur = tabs.len
    cur.tabs @= tabs
    loadFileUUID(file_dropped)
  )
  current_tab_target = 0
  file_dropped = 0
)

right_target = -5
if state.folder_sidebar (
  state.folder_sidebar_width ??= 300
  right_target -= state.folder_sidebar_width
)
right_smooth += right_target - right_smooth / 5
right = w.right + right_smooth

bottom_target = 5
if state.linked_windows_view (
  bottom_target += 150
)
bottom_smooth += bottom_target - bottom_smooth / 5
bottom = w.bottom + bottom_smooth

// folder sidebar resizing
if state.folder_resizing and !mouse_down (
  state.folder_resizing = false
)
if !file_dragging and !tab_dragging and (state.folder_sidebar or right_smooth < -10) (
  // only allow grabbing inside the main work area
  if mouse_y > w.bottom and mouse_y < (w.top - 40) and abs(mouse_x - right) < 8 (
    cursor "ew-resize"
    if mouse_ondown (
      state.folder_resizing = true
      state.folder_resize_start_x = mouse_x
      state.folder_resize_start_w = state.folder_sidebar_width ?? 300
    )
  )
)
if state.folder_resizing (
  state.folder_sidebar_width = (state.folder_resize_start_w + (state.folder_resize_start_x - mouse_x)).clamp(200, w.width - 250)
  right_target = -5 - state.folder_sidebar_width
  right_smooth = right_target
  right = w.right + right_smooth
)

if file_dragging or tab_dragging (
  current_tab_target = 0
)

window.dragbox = [[1,1,0,0], [1,1,0,0]]
// entire tabs area
frame w.left + 5 w.top right w.top - 40 (
  ensureSplitSizes()
  local sections = split_tabs.len
  local total_w = frame.width
  local x = 0
  for i sections (
    local cur @= split_tabs[i]
    tabs @= cur.tabs
    current_tab_split = i
    current_tab = cur.cur
    local fw = total_w * state.split_sizes[i]
    frame frame.left + x frame.top frame.left + fw + x frame.bottom - 20 [cur.tab_width.toNum() + (i == sections ? 200 100),0] "split_" ++ i (
      draw_tabs
      if mouse_x > frame.left and mouse_x < frame.right (
        number frame_left = frame.x - window.x + x_position
        number frame_right = min(frame.x - window.x + frame.right, window.right - 140)
        if frame_left < frame_right (
          window.dragbox = [
            [9999, 2, frame_left, 0],
            [9999, 2, frame_right, -40]
          ]
        )
      )
    )
    cur.tab_width = tab_width
    if tabs.len == 0 (
      cur.cur = 1
    ) else (
      cur.cur = current_tab.clamp(1, tabs.len)
    )
    cur.tabs @= tabs
    split_tabs[i] @= cur
    x += fw
  )
)

// remove empty tab sections
local cleanup_i = split_tabs.len
loop cleanup_i (
  local s @= split_tabs[cleanup_i]
  if s == null or s.tabs == null or s.tabs.len == 0 (
    split_tabs.delete(cleanup_i)
  )
  cleanup_i --
)
if split_tabs.len == 0 (
  window.close()
)

draw_buttons

current_split_target = 0
if file_dragging or tab_dragging (
  frame window.left + 5 window.top - 40 right bottom (
    local sections = split_tabs.len + 1
    local fw = frame.width / sections
    local x = 0
    for i sections (
      frame frame.left + x frame.top frame.left + fw + x frame.bottom (
        if mouse_x > frame.left and mouse_x < frame.right and mouse_y > frame.bottom and mouse_y < frame.top (
          current_split_target = i
          state.draw_highlight = [x, fw]
        )
        x += fw
      )
    )
  )
)

if tab_dragging (
  file_dropped = 0
)

if tab_dragging and !mouse_down (
  local placed = false

  if typeof(current_tab_target) == "string" and current_tab_target.contains(",") (
    local spl = current_tab_target.split(",")
    local dest_split = spl[1].toNum()
    local dest_index = spl[2].toNum()

    if dest_split >= 1 and dest_split <= split_tabs.len (
      local dest @= split_tabs[dest_split]
      dest_index = dest_index.clamp(1, dest.tabs.len + 1)
      dest.tabs.insert(dest_index, tab_drag_tab)
      dest.cur = dest_index
      split_tabs[dest_split] @= dest
      placed = true
    )
  )

  if !placed and current_split_target != 0 (
    split_tabs.insert(current_split_target, {tabs: [tab_drag_tab], cur: 1})
    placed = true
  )

  if !placed and tab_drag_from_split != 0 (
    local src @= split_tabs[tab_drag_from_split]
    local idx = tab_drag_from_index.clamp(1, src.tabs.len + 1)
    src.tabs.insert(idx, tab_drag_tab)
    src.cur = idx
    split_tabs[tab_drag_from_split] @= src
  )

  tab_dragging = false
  tab_drag_tab = null
  tab_drag_from_split = 0
  tab_drag_from_index = 0
  tab_drag_candidate = null
  current_tab_target = 0
  current_split_target = 0
  state.draw_highlight = [0,0]
)

// top level area for the editor itself
frame window.left + 5 window.top - 40 right bottom (
  ensureSplitSizes()
  local sections = split_tabs.len
  local total_w = frame.width
  local x = 0

  // split resizing (grab vertical boundaries between sections)
  if state.split_resizing != 0 and !mouse_down (
    state.split_resizing = 0
  )

  // determine boundaries from current sizes
  local running = 0
  for i (sections - 1) (
    running += total_w * state.split_sizes[i]
    local split_x = frame.left + running
    if !file_dragging and !tab_dragging and state.split_resizing == 0 (
      if mouse_y > frame.bottom and mouse_y < frame.top and abs(mouse_x - split_x) < 8 (
        cursor "ew-resize"
        if mouse_ondown (
          state.split_resizing = i
          state.split_resize_start_x = mouse_x
          state.split_resize_start_left = state.split_sizes[i]
          state.split_resize_start_right = state.split_sizes[i + 1]
        )
      )
    )
  )

  if state.split_resizing != 0 (
    local idx = state.split_resizing
    local pair_sum = state.split_resize_start_left.toNum() + state.split_resize_start_right.toNum()
    local delta = (mouse_x - state.split_resize_start_x).toNum() / total_w
    local tab_left = (state.split_resize_start_left.toNum() + delta).clamp(0.08, pair_sum - 0.08)
    local tab_right = pair_sum - tab_left
    state.split_sizes[idx] = tab_left
    state.split_sizes[idx + 1] = tab_right
  )

  // render sections using split sizes
  for i sections (
    local fw = total_w * state.split_sizes[i]
    frame frame.left + x frame.top frame.left + fw + x frame.bottom 0 (
      local cur @= split_tabs[i]
      tabs @= cur.tabs
      current_tab = cur.cur
      func @= tabs[current_tab].func
      if typeof(func) == "function" (
        sidebar.frameInnerRender(func)
      )
      cur.cur = current_tab
      cur.tabs @= tabs
    )
    x += fw
  )

  if current_split_target != 0 (
    x = state.draw_highlight[1]
    fw = state.draw_highlight[2]
    frame frame.left + x frame.top frame.left + fw + x frame.bottom (
      c c_text
      pen "opacity" 50
      icon "dot 0 0" 10000
    )
  )
)

if state.folder_sidebar or right_smooth < -10 (
  frame right + 5 window.top - 40 window.right - 5 window.bottom + 5 (
    goto 0 0
    square frame.width - 10 frame.height - 10 10 : c#window_colour
    if state.is_opal (
      goto 0 frame.top - 20
      square frame.width - 10 30 10 : c#c_prim
      set_x frame.left + 20
      square 20 20 10 : c#c_seco
      if onclick (
        local open_path = state.folder
        local root_dir = open(open_path, ["location", "name"]).join("/")
        local path = root_dir ++ "/opal.json"
        if !path.fileExists() (
          say "opal.json not found"
        ) else (
          opal_json = open(path).JsonParse()
          script = opal_json.main
          if script == null (
            say "No main() function found in opal.json"
          ) else (
            open_path = root_dir ++ "/" ++ script
            if !open_path.fileExists() (
              say "Script not found"
            ) else (
              file "open" open_path "onlyaccess"
              if fileGet(1) == ".osl" (
                file "start"
              )
              file "close"
            )
          )
        )
      )
      icon "play" 0.6 : c#c_text
    )
  )
  c c_prim
  frame right + 5 window.top - (state.is_opal ? 75 40) window.right - 5 window.bottom + 5 state.folder_list_len "cache@folders" (
    if file_dragging and mouse_x > frame.left and mouse_x < frame.right and mouse_y > frame.bottom and mouse_y < frame.top (
      square frame.width - 10 frame.height - 10 10 : c#c_prim
      icon "open" 3 : c#c_text
      current_tab_target = "folder_sidebar"
    ) else (
      if state.folder != null and state.folder_open (
        local files = open(state.folder)
        state.folder_list_len = files.len * 30
        local cur @= split_tabs[split_tabs.len]
        tabs @= cur.tabs
        current_tab = cur.cur
        loc 2 2 25 -25 + frame.scroll
        drawFilesList(files)
        cur.tabs @= tabs
        cur.cur = current_tab
        split_tabs[split_tabs.len] @= cur
      ) else (
        loc 2 2 10 -20
        text "No folder selected\nDrag and drop a folder here" 9 : c#c_text
        local rf_preview = ("recent_folders.json".saveGet() ?? []).trim(1,5)
        if rf_preview.len != 0 (
          loc 2 2 10 -80
          text "Recent folders" 9 : c#c_text
          change_y -30
          for i rf_preview.len (
            local uuid @= rf_preview[i]
            file "open" uuid "onlyaccess"
            if fileGet(1) != ".folder" (
              continue
            )
            set_x 0
            square frame.width - 20 20 8 : c#c_prim cursor#pointer
            if mouse_touching (
              square frame.width - 20 20 8 : c#c_seco
              if onclick (
                state.folder = uuid
                state.folder_open = true
                state.open_folders = []
                state.is_opal = open(uuid, ["location", "name"])
                  .join("/").listFolder()
                  .contains("opal.json")
                local rf = "recent_folders.json".saveGet() ?? []
                save "recent_folders.json" "set" rf
                  .delete(uuid)
                  .prepend(uuid)
                  .trim(1,8)
              )
            )
            set_x frame.left + 25
            file "render" 0.7
            text fileGet(2) 9 : c#c_text chx#20
            change_y -35
          )
        )
      )
    )
  )
)

if tab_dragging and tab_drag_tab != null (
  frame window.left window.top window.right window.bottom (
    goto mouse_x mouse_y
    local name = tab_drag_tab.name ?? ""
    local l = name.len * 9 + 35
    pen "opacity" 85
    square l 20 10 : c#window_colour
    pen "opacity" 100
    c c_text
    change_x l / -2 + 10
    text name 9
  )
)
