import as "glass" from "packages"
import "window_tools"

permission "request" "terminal"
permission "request" "file admin"
save "system@terminal" "set_directory"
network "set_app_id" "terminal@system"

// fetch the path tracker file
path_url = "https://origin.mistium.com/%3Apath/"
path = (path_url ++ "osl-tracker.json").httpGet()
if typeof(path) !== "object" (
  path = {}
)

inputs.main = ""
number cursor_pos = 1

path = path.scripts.getValues()

def evalCmd(cmd) (
  local tokens = cmd.oslTokenise()
  local path = parseFilePath("~/:path/" ++ tokens[1] ++ ".osl")
  file "exists" path
  local data = open(path)
  if data == null or !exists (
    terminal_output = []
    terminal cmd
    return terminal_output
  )
  local fn @= function("args", data)
  void tokens.shift()
  local lines = terminal.lines
  for i tokens.len (
    local cur = tokens[i]
    if cur[1] == "\"" and cur[-1] == "\"" (
      tokens[i] = cur.trim(2, -2).replace("\\", "")
    )
    if cur[1] == "(" and cur[-1] == ")" (
      terminal.lines = []
      evalCmd(cur.trim(2, -2))
      if terminal.lines.len > 0 (
        tokens[i] @= terminal.lines.join("\n")
      ) else (
        tokens[i] = null
      )
    )
  )
  terminal.lines = []
  void fn.apply(terminal_worker, [tokens])
  local out @= terminal.lines
  terminal.lines = lines
  return out
)

class terminal (
  lines = []
  waiting = false
  show_input = true
  input_message = null
  pwd = user_folder
  
  def writeLine(data) (
    if data.contains("\n") (
      local parts = data.split("\n")
      for i parts.len (
        void self.lines.append(parts[i])
      )
    ) else (
      void self.lines.append(data)
    )
  )
  
  def write(data) (
    self.lines[self.lines.len] += data
  )
  
  def clear() (
    terminal.lines = []
  )
  
  def input(query) (
    self.show_input = true
    self.input_message = query
    while self.show_input (
      defer
    )
    self.input_message = null
    return last.pop()
  )
  
  def user_start() (
    if self.input_message != null (
      return self.input_message ++ ": "
    )
    local pos = self.pwd
    if pos == user_folder (
      pos = "~"
    ) else (
      pos = pos.split("/")[-1]
    )
    return username ++ "@originos " ++ pos ++ " % "
  )

  def run(cmd) (
    return terminal_worker.evalCmd(cmd)
  )
)

if typeof(passed_data) == "object" (
  switch passed_data["type"] (
    case "cd"
      terminal.pwd = parseFilePath(passed_data["location"])
      break
  )
)

canenter = true
inputs.main = null
last = []
last_index = 0

window.setDragbox([2,2,0,0],[-2,-2,0,0])

taking_input = false
ots_i = 1

if path.len > 0 (
  path_folder = parseFilePath("~/:path.folder")
  file "exists" path_folder
  if exists.not() (
    file "goto_dir" user_folder
    file "set_file" ":path.folder" []
  )

  path_worker @= worker({
    isThread: true,
    onframe: def() -> (
      local updates = []
      for i path.len (
        local cur = path[i]
        local cmd_path = parseFilePath("~/:path/" ++ cur.name)
        file "exists" cmd_path
        if exists (
          if cur.status == "removed" (
            file "open" cmd_path "onlyaccess"
            file "delete"
            continue
          )
          local data = open(cmd_path, ["edited"])
          if data[1] != cur.lastModifiedUnix (
            void updates.append(cur)
          )
        ) else if cur.status != "removed" (
          void updates.append(cur)
        )
      )
      if updates.len > 0 (
        terminal.writeLine("Updates found for the following scripts:")
        for i updates.len (
          terminal.writeLine("- " ++ updates[i].name)
        )
        if terminal.input("Update them? (y/n)") == "y" (
          file "goto_dir" "~/:path"
          for i updates.len (
            local cur = updates[i]
            file "set_file" cur.name (path_url ++ cur.name).httpGet()
            file "open" cur.name "onlyaccess"
            file "set" "edited" cur.lastModifiedUnix
            terminal.writeLine("Updated " ++ cur.name)
          )
        )
      )
      terminal.lines = []
      terminal.show_input = true
      path_worker.kill()
    )
  })
  terminal.writeLine("Checking for updates...")
)

terminal_worker @= worker({
  cmd: null,
  isThread: true,
  cache: {},
  evalCmd,
  onframe: def() -> (
    if cmd != null (
      terminal.show_input = false
      terminal.lines ++= self.evalCmd(cmd)
      terminal.show_input = true
      self.cmd = null
    )
  )
})

mainloop:
load_theme

glass:frame window.left window.top window.right window.bottom
c window_colour
pen "opacity" 60
icon "w 999 dot 0 0" 100
frame "clear"

c prim
frame window.left window.top window.right + 20 window.bottom loops + 1.5 * 20 (
  c txtc
  loops = terminal.lines.len
  count = floor(scroll_y / 20).clamp(0,loops)
  loop round(frame.height / 20 + 3).clamp(0,loops) (
    count ++
    y = count * -20 + frame.scroll + 5
    loc 2 2 10 y
    local line = terminal.lines[count]
    if line == null (
      break
    )
    if typeof(line) == "array" (
      local i = 0
      loop line.len / 2 (
        i += 2
        local cur @= line[i]
        local cols @= line[i - 1]
        if typeof(cols) == "string" (
          c cols ?? txtc
        ) else (
          if cols.back != null (
            local len = cur.len * 5
            change_x len
            c cols.back.toStr()
            square len * 2 20 0
            change_x -len
          )
          c cols.text ?? txtc
        )
        text cur 10
        c txtc
      )
    ) else (
      text line 10
    )
  )

  local user_start = terminal.user_start()
  if terminal.show_input (
    loc 2 2 10 loops * -20 + scroll_y - 15
    text user_start 10 : c#txtc
    inputs.main ??= ""
    if "control".isKeyDown() or "meta".isKeyDown() (
      if "v".onKeyDown() (
        inputs.main ++= clipboard
      )
      if "arrowleft".onKeyDown() (
        cursor_pos = 1
      )
      if "arrowright".onKeyDown() (
        cursor_pos = inputs.main.len + 1
      )
    ) else (
      string append = all_hit
        .filter(v -> v.len === 1)
        .join("")
      if "shift".isKeyDown() (
        append.toUpper()
      )
      if append.len > 0 (
        inputs.main.insert(cursor_pos - 1, append)
        cursor_pos += append.len
      )
      if "arrowleft".onKeyDown() (
        cursor_pos --
      )
      if "arrowright".onKeyDown() (
        cursor_pos ++
      )
    )
    if "backspace".onKeyDown() (
      if "control".isKeyDown() (
        inputs.main = ""
        cursor_pos = 1
      ) else (
        // remove the last character
        cursor_pos --
        inputs.main = inputs.main.delete(cursor_pos)
      )
    )
    if "arrowup".onKeyDown() (
      last_index --
      last_index.clamp(1,last.len)
      inputs.main = last[last_index]
      cursor_pos = inputs.main.len + 1
    )
    if "arrowdown".onKeyDown() (
      last_index ++
      last_index.clamp(1,last.len + 1)
      inputs.main = last[last_index]
      cursor_pos = inputs.main.len + 1
    )
    cursor_pos.clamp(1,inputs.main.len + 1)
    if "enter".onKeyDown() (
      void last.append(inputs.main)
      last_index = last.len + 1
      void terminal.lines.append(terminal.user_start() ++ inputs.main)
      if inputs.main == "clear" (
        terminal.lines = []
      ) else (
        terminal.show_input = false
      )
      if terminal.input_message == null (
        terminal_worker.cmd = inputs.main
      )
      inputs.main = ""
      cursor_pos = 1
    )
    number offset = cursor_pos - 1 * 10
    change_x offset
    square 0 15 2
    change_x -offset
    text inputs.main ?? "" 10
  ) else (
    loops --
  )
)

import "win-buttons"
