if args.len == 0 (
    terminal.writeLine("Usage: sre --open <id>")
    terminal.writeLine("Usage: sre --join <id@username>")
)

class rotur (
    self._subs = {}
    self.subscriptions = () -> (self._subs.getKeys())

    def subscribe(room, username) (
        local current = "rotur.mistium.com".newWebsocket()
        self._subs[room] = {
            username,
            room: room,
            ws: current,
            ulist: [],
            linked: false,
            onlink: ()->(),
            onclose: ()->(),
            onmessage: ()->(),
            onjoin: ()->(),
            onleave: ()->()
        }
        current.wsSend({
            "cmd": "handshake",
            "val": {
            "language": "OSL",
            "version": {
                "editorType": "Origin",
                "versionNumber": origin.version,
            },
            },
            "listener": "handshake_cfg",
        })
        return self._subs[room]
    )

    def unSubscribe(room) (
        local cur = self._subs[room]
        cur.ws.wsClose()
        self._subs = self._subs.delete(room)
    )

    def isLinked(room) (
        return self._subs[room].linked
    )

    def _handleStatusCode(packet, current) (
        if packet.listener != "" (
            switch packet.listener (
            case "handshake_cfg"
                current.ws.wsSend({
                    "cmd": "setid",
                    "val": current.username,
                    "listener": "username_cfg"
                })
                break
            case "username_cfg"
                current.ws.wsSend({
                    "cmd": "link",
                    "val":[current.room],
                    "listener":"link"
                })
                break
            )
        )
    )

    def listConnected(room) (
        return self._subs[room].ulist
    )

    def pMessage(room, name, value) (
        self._subs[room].ws.wsSend({
            "cmd": "pmsg",
            "id": name,
            "val": value
        })
    )
    
    def gMessage(room, value) (
        self._subs[room].ws.wsSend({
            "cmd": "gmsg",
            "val": value
        })
    )

    def main() (
        local subs @= self._subs
        local room = ""
        each room subs.getKeys() (
            local current @= subs[room]
            if !current.ws.wsOpen() (
                void current.onclose()
                continue
            )
            if current.ws.wsHasnew() (
                local packet = current.ws.wsGetnext()
                if packet.listener == "link" (
                    void current.onlink()
                    current.linked = true
                )
                switch packet.cmd (
                    case "statuscode"
                        self._handleStatusCode(packet, current)
                        break
                    case "client_ip"
                        self.ip = packet.val
                        break
                    case "ulist"
                        switch packet.mode (
                            case "set"
                                current.ulist = packet.val.getKeys("username")
                                break
                            case "add"
                                current.ulist = current.ulist.append(packet.val)
                                void current.onjoin(packet.val)
                                break
                            case "remove"
                                current.ulist = current.ulist.delete(packet.val)
                                void current.onleave(packet.val)
                                break
                        )
                        break
                    case "pmsg"
                    case "gmsg"
                        void current.onmessage(packet)
                        break
                )
            )
        )
    )
)

if args[1] == "--open" or args[1] == "-o" (
  local id = args[2]
  local username = user.username.toLower()
  local room = id ++ "@" ++ username
  local password = null

  local connection @= rotur.subscribe(room, "sre-host")
  
  local link_state = {}

  connection.onmessage @= ((packet) -> (
    local source_user = packet.origin.username
    switch packet.val.cmd (
      case "handshake"
        terminal.writeLine("Handshake received from " ++ source_user)
        if self.password == null (
          rotur.pMessage(self.room, source_user, {
             cmd: "handshake",
             success: true
          })
          self.link_state.linked_to = source_user
        )
        break
      case "run"
        local original @= terminal.writeLine
        local bound @= {
          original,
          room: self.room,
          rotur: self.rotur,
          lines: []
        }
        terminal.writeLine @= (def(data) -> (
            void self.original.apply(terminal, [data])
            void lines.append(data)
            if lines.len > 4 (
              void rotur.pMessage(self.room, "sre-connect", {cmd: "writeLines", data: lines.trim(1, 10)})
              self.lines @= self.lines.trim(11, -1)
            )
        )).bind(bound)
        
        void terminal.run(packet.val.data)
        void rotur.pMessage(self.room, "sre-connect", {cmd: "writeLines", data: bound.lines})
        terminal.writeLine @= original
        void rotur.pMessage(self.room, "sre-connect", {cmd: "done", pwd: terminal.pwd})
        break
    )
  )).bind({rotur, room, password, link_state})

  terminal.writeLine("Connecting to rotur...")
  connection.onlink @= (def() -> (
    terminal.writeLine("Hosting as " ++ self.room)
    terminal.writeLine("Press enter to stop")
  )).bind({room})
  local linked = false
  local connected = {username: null}
  
  window "responsive" true
  
  defer
  while true (
    if "enter".onKeyDown() and focused_application_id == window.id (
      window "responsive" false
      return
    )
    rotur.main()
    defer
  )
)

if args[1] == "--join" or args[1] == "-j" (
  local parts = args[2].split("@")
  local id = parts[1]
  local username = parts[2].toLower()

  local linked = false

  local connection @= rotur.subscribe(id ++ "@" ++ username, "sre-connect")
  
  object states = {
    idle: 0,
    waiting: 1
    state: 0
  }
  states.state = states.idle
  
  local room @= id ++ "@" ++ username

  connection.onmessage @= (def(packet) -> (
    local data @= packet.val
    switch data.cmd (
      case "handshake"
        if data.success (
          terminal.writeLine("Connected")
          terminal.show_input = true
          self.states.state = states.idle
          self.cmd = null
        )
        break
      case "syncLines"
        terminal.lines @= data.data
        break
      case "writeLines"
        for i data.data.len (
          void terminal.lines.append(data.data[i])
        )
        break
      case "done"
        terminal.pwd = data.pwd
        self.states.state = states.idle
        terminal.show_input = true
        self.cmd = null
        break
    )
  )).bind({term_worker, states})

  connection.onlink @= (def() -> (
    terminal.writeLine("Handshaking with " ++ self.room)
    rotur.pMessage(self.room, "sre-host", {
        cmd: "handshake",
        success: true
    })
  )).bind({room})
  
  self.cmd = null
  
  while true (
    rotur.main()
    if self.cmd != null and states.state == states.idle (
      if self.cmd == "clear" (
        terminal.clear()
      ) else (
        rotur.pMessage(room, "sre-host", {cmd: "run", data: self.cmd})
        states.state = states.waiting
      )
      terminal.show_input = false
      self.cmd = null
    )
    defer
  )
)